# 생산자 소비자 문제2

## Lock Condition - 예제4

생산자가 생산자를 깨우고, 소비자가 소비자를 깨우는 비효율 문제를 어떻게 해결할 수 있을까?

**해결 방안**
핵심은 생산자 스레드는 데이터를 생성하고, 대기중인 소비자 스레드에게 알려주어야 한다. 

반대로 소비자 스레드는 데이터를 소비하고, 대기중인 생산자 스레드에게 알려주면 된다. 

결국 생산자 스레드가 대기하는 대기 집합과, 소비자 스레드가 대기하는 대기 집합을 둘로 나누면 된다. 

그리고 생산자 스레드가 데이터를 생산하면 소비자 스레드가 대기하는 대기 집합에만 알려주고, 소비자 스레드가 데이터를 소비하면 생산자 스레드가 대기하는 대기 집합에만 열려주면 되는것이다. 

이렇게 생산자용, 소비자용 대기 집합을 서로 나누어 분리하면 비효율 문제를 깔끔하게 해결할 수 있다.

그럼 대기 집합을 어떻게 분리할 수 있을까? 바로 앞서 학습한 `Lock` , `ReentrantLock` 을 사용하면 된다.

**참고**: 

자바는 1.0부터 존재한 `synchronized` 와 `BLOCKED` 상태를 통한 임계 영역 관리의 단점을 해결하기 위해 자바 1.5부터 `Lock` 인터페이스와 `ReentrantLock` 구현체를 제공한다.

우선 대기 집합을 분리해서 문제를 해결하기 전에, 앞서 `synchronized` , `Object.wait()` , `Object.notify()` 를 통해 작성한 코드를 `Lock` 인터페이스와 ReentrantLock` 구현체를 사용해서 그대로 다시 구현해보자.
